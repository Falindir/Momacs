<div>
   <p id="mode"><b>Mode </b>: nothing</p>
   <p id="indeximagecanvas"><b>Images: </b> 0 / 0</p>
   <canvas id="canvas" width="800" height="600" style="cursor:crosshair;"></canvas>
</div>

<script>

$('#canvas').css('background-color', 'rgba(127, 140, 141, 0.2)');

var momacs_config = null;

var canvas = document.getElementById("canvas");
canvas.started = false;
canvas.width = 800;
canvas.height = 600;
canvas.state = "nothing";
canvas.scaleFactor = 1.05;
canvas.pointSize = 6; // default we change that in settings
canvas.lastX=canvas.width/2;
canvas.lastY=canvas.height/2;
canvas.currentScale = 1;
canvas.imagePath = "";
canvas.typeofcurve = "close";

var zone = null;
var ctx = null;
var ima1 = null;

window.onload = function(){ 
  
document.body.style.mozUserSelect = document.body.style.webkitUserSelect = document.body.style.userSelect = 'none';
          
ctx = canvas.getContext('2d');
trackTransforms(ctx);

zone = new ZoneP();

//===========================================================================

canvas.addEventListener('click',function(evt)
{
  if(canvas.started) {
      var pt = this.getPosition(evt);
    
      if(canvas.state == "drawPoint") {
          zone.addPoint(pt);
      } else if(canvas.state == "drawSegment") {
          zone.addSegment(pt);
      } else if(canvas.state == "drawCurve") {
          zone.addCurve(pt);
      } else if(canvas.state == "deletePoint") {
          zone.deletePoint(pt);
      } else if(canvas.state == "deletePointSegment") {
          zone.deleteSegment(pt);
      } else if(canvas.state == "deletePointCurve") {
          zone.deleteCurve(pt);
      } else if(canvas.state == "addPointOnSegment") {
          zone.addPoinSegment(pt);
      } else if(canvas.state == "addPointOnCurve") {
          zone.addPointCurve(pt);
      }
    
     this.redraw();
  }
},false);

//===========================================================================

canvas.addEventListener('mousedown',function(evt)
{
  if(canvas.started) {
    var pt = this.getPosition(evt);
    if(canvas.state == "move") {
        zone.dragStart = pt;
    } else if(this.state == "movePoint") {
        zone.movePoint(pt);
    } else if(this.state == "movePointSegment") {
        zone.moveSegment(pt);
    } else if(this.state == "movePointCurve") {
        zone.moveCurve(pt);
    }
  }
},false);

//===========================================================================

canvas.addEventListener('mouseup',function(evt)
{
  if(this.started) {
    if(this.state == "move") {
        zone.dragStart = null;
    }
    
    if(this.state == "movePoint" || this.state == "movePointSegment" || this.state == "movePointCurve") {
        zone.draggedPoint = null;
    }
  }
},false);

//===========================================================================

canvas.addEventListener('mouseleave',function(evt)
{
  if(this.started) {
    if(this.state == "move") {
        zone.dragStart = null;
    }
    if(this.state == "movePoint" || this.state == "movePointSegment" || this.state == "movePointCurve") {
        zone.draggedPoint = null;
    }
  }
},false);

//===========================================================================

canvas.addEventListener('mousemove',function(evt){
    if(canvas.started) {
        var pt = this.getPosition(evt);
        if(canvas.state == "move") {
              if (zone.dragStart){
                ctx.translate(pt.x-zone.dragStart.x,pt.y-zone.dragStart.y);
                this.redraw();
              }
        } else  if(this.state == "movePoint" || this.state == "movePointSegment"|| this.state == "movePointCurve") {
           if(zone.draggedPoint) {
              zone.draggedPoint.x = pt.x;
              zone.draggedPoint.y = pt.y;
              this.redraw();
           }
        } else  {
          this.redraw();
        }
    }
},false);

//===========================================================================

canvas.getPosition = function(evt) {
  this.lastX = evt.offsetX || (evt.pageX - this.offsetLeft);
  this.lastY = evt.offsetY || (evt.pageY - this.offsetTop);
  var pt = ctx.transformedPoint(this.lastX,this.lastY);
  return pt;
}

//===========================================================================

canvas.drawCoordinates = function (x,y) {
    ctx.fillStyle = momacs_config.color_point; // Red color
    ctx.beginPath(); //Start path
    ctx.arc(x, y, momacs_config.size_point, 0, Math.PI * 2, true); // Draw a point using the arc function of the canvas with a point structure.
    ctx.fill(); // Close the path and fill.
}

//===========================================================================

canvas.drawText = function(value, x, y) {
    ctx.fillStyle = momacs_config.color_text; // dark blue color
    ctx.beginPath(); //Start path
    ctx.font = momacs_config.size_text+"px Arial";
    ctx.fillText(value, x+5, y);
    ctx.fill(); // Close the path and fill.
}

//===========================================================================

canvas.drawLine = function (p1, p2) {
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = momacs_config.color_segment;
    ctx.lineWidth = momacs_config.size_segment;
    ctx.stroke();
    ctx.fill();
}

//===========================================================================

canvas.drawBezier = function (id, points) {
   if(points.length == 0) {
     return;
   }
   
   var pts = [];
   for (var i = 0; i < points.length; i++) {
     pts.push(points[i].x);
     pts.push(points[i].y);
     points[i].draw("C"+id+"-"+i);
   }

  ctx.beginPath();
  ctx.moveTo(pts[0], pts[1]);
  zone.curvesPartition[id].allpts = ctx.curve(pts, 0.5, 20, (this.typeofcurve == "close"));
	ctx.lineWidth = momacs_config.size_curve;
	ctx.strokeStyle = momacs_config.color_curve;
	ctx.stroke();
}

//===========================================================================

canvas.zoom = function(clicks){
    if(canvas.started ) {
        var pt = ctx.transformedPoint(this.lastX,this.lastY);
        ctx.translate(pt.x,pt.y);
        var factor = Math.pow(this.scaleFactor,clicks);
        this.currentScale *= factor;
        ctx.scale(factor,factor);
        ctx.translate(-pt.x,-pt.y);
        this.redraw();
    }
}

//===========================================================================

var handleScroll = function(evt){
  if(canvas.started ) {
          var delta = evt.wheelDelta ? evt.wheelDelta/40 : evt.detail ? -evt.detail : 0;
          if (delta) canvas.zoom(delta);
          return evt.preventDefault() && false;
  }
};

//===========================================================================
      
$('input[type=radio][name=typeCurve]').change(function () {
    canvas.typeofcurve = this.value;
    if(canvas.started ) {
        canvas.redraw();
    }
});
    
//===========================================================================    
      
canvas.addEventListener('DOMMouseScroll',handleScroll,false);

//===========================================================================

canvas.addEventListener('mousewheel',handleScroll,false);

//===========================================================================

canvas.redraw = function ()
{
          var p1 = ctx.transformedPoint(0,0);
          var p2 = ctx.transformedPoint(this.width,this.height);
          ctx.clearRect(p1.x,p1.y,p2.x-p1.x,p2.y-p1.y);
          ctx.save();
          ctx.setTransform(1,0,0,1,0,0);
          ctx.clearRect(0,0,this.width,this.height);
          ctx.restore();
          ctx.drawImage(ima1,0,0);
          zone.drawPoints();
          zone.drawSegments();
          zone.drawcurves();
}

//===========================================================================

var eventClickButtonChange = function(name, mode, action) {
  $(name).removeClass("btn-danger");
  $(name).addClass("btn-success");
  if(mode == action) {
    $(name).addClass("btn-danger");
    $(name).removeClass("btn-success"); 
  }
}

//===========================================================================

canvas.changeMode = function(mode) {
   $("#mode").html("<b>Mode </b>: " + mode);
   eventClickButtonChange("#buttonMoveImage", mode, "move");
   eventClickButtonChange("#buttonDrawPoint", mode, "drawPoint");
   eventClickButtonChange("#buttonDrawSegment", mode, "drawSegment");
   eventClickButtonChange("#buttonDrawCurve", mode, "drawCurve");
   eventClickButtonChange("#buttonDeletePoint", mode, "deletePoint");
   eventClickButtonChange("#buttonDeletePointSegment", mode, "deletePointSegment");
   eventClickButtonChange("#buttonDeletePointCurve", mode, "deletePointCurve");
   eventClickButtonChange("#buttonMovePoint", mode, "movePoint");
   eventClickButtonChange("#buttonMovePointSegment", mode, "movePointSegment");
   eventClickButtonChange("#buttonMovePointCurve", mode, "movePointCurve");
   eventClickButtonChange("#buttonAddPointOnSegment", mode, "addPointOnSegment");
   eventClickButtonChange("#buttonAddPointOnCurve", mode, "addPointOnCurve");
}

//===========================================================================

var actionChangeMode = function(mode) {
  if(canvas.started) {
    if(canvas.state == mode) {
      canvas.state = "nothing";
    } else {
      canvas.state = mode;
    }
    canvas.changeMode(canvas.state);
  }
}

//===========================================================================

$("#buttonMoveImage").click(function(e){ actionChangeMode("move"); });
$("#buttonDrawPoint").click(function(e){ actionChangeMode("drawPoint"); });
$("#buttonDrawSegment").click(function(e){ actionChangeMode("drawSegment"); });
$("#buttonDrawCurve").click(function(e){ actionChangeMode("drawCurve"); });
$("#buttonDeletePoint").click(function(e){ actionChangeMode("deletePoint"); });
$("#buttonDeletePointSegment").click(function(e){ actionChangeMode("deletePointSegment"); });
$("#buttonDeletePointCurve").click(function(e){ actionChangeMode("deletePointCurve"); });
$("#buttonMovePoint").click(function(e){ actionChangeMode("movePoint"); });
$("#buttonMovePointSegment").click(function(e){ actionChangeMode("movePointSegment"); });
$("#buttonMovePointCurve").click(function(e){ actionChangeMode("movePointCurve"); });
$("#buttonAddPointOnSegment").click(function(e){ actionChangeMode("addPointOnSegment"); });
$("#buttonAddPointOnCurve").click(function(e){ actionChangeMode("addPointOnCurve"); });

//===========================================================================

canvas.addOptionToList = function (element, text) {
    var option = document.createElement("option");
    option.value = text;
    option.text = text;
    option.selected = "selected";
    element.add(option);
}

canvas.rezetOptionList = function(element) {
    while (element.firstChild) {
        element.removeChild(element.firstChild);
    }
}

canvas.newEnv = function() {
    zone.rezet();
    var points = document.getElementById("selectedPartitionPoint");
    var segments = document.getElementById("selectedPartitionSegment");
    var curves = document.getElementById("selectedPartitionCurve");
    this.rezetOptionList(points);
    this.rezetOptionList(segments);
    this.rezetOptionList(curves);
    this.addOptionToList(points, "P0");
    this.addOptionToList(segments, "S0");
    this.addOptionToList(curves, "C0");
}

//===========================================================================

$("#clearImage").click(function(e){
    if(canvas.started) {
        zone.rezet();
        canvas.newEnv();
        canvas.redraw();
    }
});

//===========================================================================

$("#buttonClearPartitionPoint").click(function(e){
    if(canvas.started) {
        var part = zone.pointsPartition[zone.cidPoint];
        zone.pointsPartition[zone.cidPoint] = new Partition(part.id);
        canvas.redraw();
    }
});

//===========================================================================

$("#buttonClearPartitionSegment").click(function(e){
    if(canvas.started) {
        var part = zone.segmentsPartition[zone.cidSegment];
        zone.segmentsPartition[zone.cidSegment] = new SegmentPartition(part.id);
        canvas.redraw();
    }
});

//===========================================================================

$("#buttonClearPartitionCurve").click(function(e){
    if(canvas.started) {
        var part = zone.curvesPartition[zone.cidCurve];
        zone.curvesPartition[zone.cidCurve] = new Curve2D(part.id);
        canvas.redraw();
    }
});

//===========================================================================

$("#buttonNewPartitionPoint").click(function(e){
  if(canvas.started) {
    var x = document.getElementById("selectedPartitionPoint");
    var id = zone.pointsPartition.length;
    canvas.addOptionToList(x, "P"+id);
    zone.pointsPartition[id] = new Partition(id);
    zone.cidPoint = id;
  }
});

//===========================================================================

$("#buttonNewPartitionSegment").click(function(e){
  if(canvas.started) {
    var x = document.getElementById("selectedPartitionSegment");
    var id = zone.segmentsPartition.length;
    canvas.addOptionToList(x, "S"+id);
    zone.segmentsPartition[id] = new SegmentPartition(id);
    zone.cidSegment = id;
  }
});

//===========================================================================

$("#buttonNewPartitionCurve").click(function(e){
  if(canvas.started) {
    var x = document.getElementById("selectedPartitionCurve");
    var id = zone.curvesPartition.length;
    canvas.addOptionToList(x, "C"+id);
    zone.curvesPartition[id] = new Curve2D(id);
    zone.cidCurve = id;
  }
});

//===========================================================================

$("#buttonDeletePartitionPoint").click(function(e){
  if(canvas.started) {
    var conceptName = $('#selectedPartitionPoint').find(":selected").text();
    var option = "#selectedPartitionPoint option[value='"+conceptName+"']";
    $(option).remove();
    var id = conceptName.substring(1);
    var collectionPoint = [];
    var j = 0;
    for (var i = 0; i < zone.pointsPartition.length; i++) {
      var partition = zone.pointsPartition[i];
      if(partition.id != id) {
        collectionPoint[j] = partition;
        j++;
      } else {
        collectionPoint[j] = new Partition(id);
        collectionPoint[j].alive = false;
        j++;
      }
    }
    zone.pointsPartition = collectionPoint;
    
    zone.cidPoint = -1;
    for (var i = 0; i < zone.pointsPartition.length; i++) {
      if(zone.pointsPartition[i].alive) {
        zone.cidPoint = i;
        break;
      }
    }
  
    canvas.redraw();
  }
});

//===========================================================================

$("#buttonDeletePartitionSegment").click(function(e){
  if(canvas.started) {
    var conceptName = $('#selectedPartitionSegment').find(":selected").text();
    var option = "#selectedPartitionSegment option[value='"+conceptName+"']";
    $(option).remove();
    var id = conceptName.substring(1);
    var collectionSegment = [];
    var j = 0;
    for (var i = 0; i < zone.segmentsPartition.length; i++) {
      var partition = zone.segmentsPartition[i];
      if(partition.id != id) {
        collectionSegment[j] = partition;
        j++;
      } else {
        collectionSegment[j] = new SegmentPartition(id);
        collectionSegment[j].alive = false;
        j++;
      }
    }
    
    zone.segmentsPartition = collectionSegment;

    zone.cidSegment = -1;
    for (var i = 0; i < zone.segmentsPartition.length; i++) {
      if(zone.segmentsPartition[i].alive) {
        zone.cidSegment = i;
        break;
      }
    }

    canvas.redraw();
  }
});

//===========================================================================

$("#buttonDeletePartitionCurve").click(function(e){
  if(canvas.started) {
    var conceptName = $('#selectedPartitionCurve').find(":selected").text();
    var option = "#selectedPartitionCurve option[value='"+conceptName+"']";
    $(option).remove();
    var id = conceptName.substring(1);
    var collectionCurve = [];
    var j = 0;
    for (var i = 0; i < zone.curvesPartition.length; i++) {
      var partition = zone.curvesPartition[i];
      if(partition.id != id) {
        collectionCurve[j] = partition;
        j++;
      } else {
        collectionCurve[j] = new Curve2D(id);
        collectionCurve[j].alive = false;
        j++;
      }
    }
    zone.curvesPartition = collectionCurve;
    
    zone.cidCurve = -1;
    for (var i = 0; i < zone.curvesPartition.length; i++) {
      if(zone.curvesPartition[i].alive) {
        zone.cidCurve = i;
        break;
      }
    }
    canvas.redraw();
  }
});

//===========================================================================

$( "#selectedPartitionPoint" ).change(function() {
    zone.cidPoint = $('#selectedPartitionPoint').find(":selected").text().substring(1);
});

//===========================================================================

$( "#selectedPartitionSegment" ).change(function() {
    zone.cidSegment = $('#selectedPartitionSegment').find(":selected").text().substring(1);
    zone.newA = null;
    zone.newB = null;
});

//===========================================================================

$( "#selectedPartitionCurve" ).change(function() {
    zone.cidCurve = $('#selectedPartitionCurve').find(":selected").text().substring(1);
    zone.newCA = null;
    zone.newCB = null;
});

//===========================================================================

function trackTransforms(ctx){
      var svg = document.createElementNS("http://www.w3.org/2000/svg",'svg');
      var xform = svg.createSVGMatrix();
      ctx.getTransform = function(){ return xform; };

      var savedTransforms = [];
      var save = ctx.save;
      ctx.save = function(){
          savedTransforms.push(xform.translate(0,0));
          return save.call(ctx);
      };
    
      var restore = ctx.restore;
      ctx.restore = function(){
        xform = savedTransforms.pop();
        return restore.call(ctx);
		      };

      var scale = ctx.scale;
      ctx.scale = function(sx,sy){
        xform = xform.scaleNonUniform(sx,sy);
        return scale.call(ctx,sx,sy);
		      };
    
      var rotate = ctx.rotate;
      ctx.rotate = function(radians){
          xform = xform.rotate(radians*180/Math.PI);
          return rotate.call(ctx,radians);
      };
    
      var translate = ctx.translate;
      ctx.translate = function(dx,dy){
          xform = xform.translate(dx,dy);
          return translate.call(ctx,dx,dy);
      };
    
      var transform = ctx.transform;
      ctx.transform = function(a,b,c,d,e,f){
          var m2 = svg.createSVGMatrix();
          m2.a=a; m2.b=b; m2.c=c; m2.d=d; m2.e=e; m2.f=f;
          xform = xform.multiply(m2);
          return transform.call(ctx,a,b,c,d,e,f);
      };
    
      var setTransform = ctx.setTransform;
      ctx.setTransform = function(a,b,c,d,e,f){
          xform.a = a;
          xform.b = b;
          xform.c = c;
          xform.d = d;
          xform.e = e;
          xform.f = f;
          return setTransform.call(ctx,a,b,c,d,e,f);
      };
    
      var pt  = svg.createSVGPoint();
      ctx.transformedPoint = function(x,y){
          pt.x=x; pt.y=y;
          return pt.matrixTransform(xform.inverse());
      }
}

}

//===========================================================================

canvas.loadCanvas = function (dataimage) {
  
  canvas.newEnv();
  
  var PP = dataimage.result.MultiPoints;
  var px = document.getElementById("selectedPartitionPoint");
  this.rezetOptionList(px);
  
  for (var i = 0; i < PP.length; i++) {
    var ptp = PP[i];
    var partition = new Partition(i);
    for (var j = 0; j < ptp.length; j++) {
      var points = ptp[j];
      partition.addNewPoint(points[0], points[1]);
    }
    zone.pointsPartition[i] = partition;
    zone.cidPoint = i;
    this.addOptionToList(px, "P"+i);
  }
  
  if(PP.length == 0) {
    zone.pointsPartition[i] = new Partition(0);
    zone.cidPoint = 0;
    this.addOptionToList(px, "P0");
  }
  
  var MLS = dataimage.result.MultiLineString;
  var sx = document.getElementById("selectedPartitionSegment");
  this.rezetOptionList(sx);
  
  var cx = document.getElementById("selectedPartitionCurve");
  this.rezetOptionList(cx);

  var indexSP = 0;
  var indexCP = 0;
  for (var i = 0; i < MLS.length; i++) {
    var ptp = MLS[i];
    if(ptp.length == 1) {
       //segments MultiLineString
       ptp = ptp[0];
       var partition = new SegmentPartition(indexSP);
      
       for (var j = 0; j < ptp.length; j++) {
         var points = ptp[j];
         partition.addNewPoint(points[0], points[1]);
       }
       
        zone.segmentsPartition[indexSP] = partition;
        zone.cidSegment = indexSP;
        this.addOptionToList(sx, "S"+indexSP);
        indexSP++;
    } else {
      ptp = ptp[0];
      var partition = new Curve2D(indexCP);
      for (var j = 0; j < ptp.length; j++) {
         var points = ptp[j];
         partition.addNewPoint(points[0], points[1]);
       }
       zone.curvesPartition[indexCP] = partition;
       zone.cidCurve = indexCP;
       this.addOptionToList(cx, "C"+indexCP);
       indexCP++;
    }
    
  }
  
  var MP = dataimage.result.MultiPolygon;
  for (var i = 0; i < MP.length; i++) {
    var ptp = MP[i];
    if(ptp.length == 1) {
       //segments MultiPolygon
       ptp = ptp[0];
       var partition = new SegmentPartition(indexSP);

       for (var j = 0; j < ptp.length; j++) {
         var points = ptp[j];
         partition.addNewPoint(points[0], points[1]);
       }
       
       partition.content[partition.content.length-1].p2 = partition.content[0].p1;
      
        zone.segmentsPartition[indexSP] = partition;
        zone.cidSegment = indexSP;
        this.addOptionToList(sx, "S"+indexSP);
        indexSP++;
    } else {
      ptp = ptp[0];
      var partition = new Curve2D(indexCP);
      for (var j = 0; j < ptp.length; j++) {
         var points = ptp[j];
         partition.addNewPoint(points[0], points[1]);
       }
       zone.curvesPartition[indexCP] = partition;
       zone.cidCurve = indexCP;
       this.addOptionToList(cx, "C"+indexCP);
       indexCP++;
    }
    
  }
  
  if(indexSP == 0) {
    zone.segmentsPartition[i] = new SegmentPartition(0);
    zone.cidSegment = 0;
    this.addOptionToList(sx, "S0");
  }
  
    if(indexCP == 0) {
    zone.curvesPartition[i] = new Curve2D(0);
    zone.cidCurve = 0;
    this.addOptionToList(cx, "C0");
  }

  this.redraw();
}

//===========================================================================

function drawImage(path) {
    var p1 = ctx.transformedPoint(0,0);
    var p2 = ctx.transformedPoint(canvas.width,canvas.height);
    ctx.clearRect(p1.x,p1.y,p2.x-p1.x,p2.y-p1.y);
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.restore();
    ima1 = new Image;
    ima1.onload = function () {
        ctx.drawImage(ima1,0,0);
    };
    ima1.src = path;
}

//===========================================================================

function round3(number) {
  var factor = Math.pow(10, 3);
  return Math.round(number * factor) / factor;
}

/**
 * Object Point2D  
 **/
var Point2D = function (x,y) {
  this.x = x;
  this.y = y;
  this.printed = true;
  
  this.draw = function(value) {
    canvas.drawCoordinates(this.x, this.y);
    canvas.drawText(value, this.x, this.y);
  }
  
  this.equal = function(point) {
    if(this.x == point.x) {
      if(this.y == point.y) {
        return true;
      }
    }
    return false;
  }
  
  this.distance = function (p2) {
    return Math.sqrt(Math.pow(p2.x - this.x, 2) + Math.pow(p2.y - this.y, 2));
  }
  
  this.middle = function(p2) {
    var nx = (this.x + p2.x) / 2;
    var ny = (this.y + p2.y) / 2;
    var p = new Point2D(nx, ny);
    return p;
  }
  
  this.toMOM = function() {
      return round3(this.x) + " " + round3(this.y);
  }
  
  this.toYML = function() {
    return "[" + round3(this.x) + ", " + round3(this.y) + "]";
  }

}

//===========================================================================

/**
 * Object Segment2D
 **/
var Segment2D = function (p1, p2) {
  this.p1 = p1;
  this.p2 = p2;
  
  this.draw = function () {
    canvas.drawCoordinates(this.p1.x, this.p1.y);
    canvas.drawCoordinates(this.p2.x, this.p2.y);
    canvas.drawLine(this.p1, this.p2);
  }
  
  this.equal = function(segment) {
    if(this.p1.equal(segment.p1)) {
      if(this.p2.equal(segment.p2)) {
          return true;
      }
    }
    
    if(this.p1.equal(segment.p2)) {
      if(this.p2.equal(segment.p1)) {
          return true;
      }
    }
   
    return false; 
  }
}

//===========================================================================

var Curve2D = function (id) {
   this.id = id;
   this.points = [];
   this.allpts = null;
   this.alive = true;
   
   this.notEmpty = function() {
     return this.size() != 0;
   }
   
   this.addNewPoint = function(x, y) {
      var point = new Point2D(x, y);
      this.points.push(point);
   }
   
   this.size = function() {
     return this.points.length;
   }
   
   this.movePoint = function(x, y) {
      var position = new Point2D(x, y); 
      for (var j = 0; j < this.size(); j++) {
          if(position.distance(this.points[j]) <= canvas.pointSize) {
              zone.draggedPoint = this.points[j];
              return;
          }
      }
   }
   
   this.remove = function(x, y) {
       var position = new Point2D(x, y);
       for (var j = 0; j < this.size(); j++) {
          if(position.distance(this.points[j]) <= canvas.pointSize) {
              var nc = [];
              for (var k = 0; k < j; k++) {
                nc.push(this.points[k]);
              }
              for (var k = j+1; k < this.size(); k++) {
                nc.push(this.points[k]);
              }
              this.points = nc;
              return;
          }
       }
   }
   
   this.toYML = function() {
     var txt = "";
     
     if(this.size() > 0) {
        txt = "[[";
      
          for (var j = 0; j < this.size(); j++) {
             var p = this.points[j];

             
             if(j < this.size()-1) {
               txt = txt + p.toYML() + ", ";
             } else {
               txt = txt + p.toYML();
             }
           }
        txt = txt + "],[";
        
        for (var k = 0; k < this.allpts.length; k++) {
          var p = this.allpts[k];
            if(k < this.allpts.length - 1) {
              txt = txt + round3(p) + ", ";
            } else {
              txt = txt + round3(p);
            }
        }
      
         txt = txt + "]]";
     } else {

     }
     
     return txt;
   }
   
   this.toMOM = function() {
      var txt = "";

      if(this.size() > 0) {
          if(canvas.typeofcurve == "open") {
            txt ="#LineString\n";
          } else { 
            txt = "#Polygon\n";
          }
  
          for (var j = 0; j < this.size(); j++) {
            txt = txt + this.points[j].toMOM() + "\n";
          }
         
          if(canvas.typeofcurve == "open") {
            txt = txt + "#LineString_all\n";
          } else { 
            txt = txt + "#Polygon_all\n";
          }

          var index = 1;
          for (var k = 0; k < this.allpts.length; k++) {
             x = this.allpts[k];
              if(index == 2) {
                txt = txt + round3(x) + "\n";
                index = 0;
              } else {
                txt = txt + round3(x) + " ";
              }
              index++;
          }
       }
       
      return txt;
   }
}

//===========================================================================

var SegmentPartition = function(id) {
   this.id = id;
   this.content = [];
   this.firstSegment = true;
   this.alive = true;
   
   this.add = function(segment) {
     this.content.push(segment);
   }
   
   this.addNewSegment = function(p1, p2) {
     var segment = new Segment2D(p1, p2);
     this.content.push(segment);
   }
   
   this.addNewPoint = function(x, y) {
      var point = new Point2D(x, y);
      if(this.firstSegment) {
        if(this.size() == 0) {
          this.addNewSegment(point, null);
        } else {
          this.content[this.size()-1].p2 = point;
          this.firstSegment = false;
        }
      } else {
        var last = this.content[this.size()-1].p2;
        this.addNewSegment(last, point);
      }
   }
   
   this.movePoint = function(x, y) {
      var position = new Point2D(x, y); 
      for (var j = 0; j < this.size(); j++) {
          if(position.distance(this.content[j].p1) <= canvas.pointSize) {
              zone.draggedPoint = this.content[j].p1;
              return;
          } else if(position.distance(this.content[j].p2) <= canvas.pointSize) {
             zone.draggedPoint = this.content[j].p2;
             return;
          }
      }
   }
   
   this.notEmpty = function() {
     return this.size() != 0;
   }
   
   this.draw = function() {
         var index = 0;
    
        for (var j = 0; j < this.size(); j++) {
            this.content[j].p1.printed = true;
            if(this.content[j].p2) {
              this.content[j].p2.printed = true;
            }
        }
                  
        for (var j = 0; j < this.size(); j++) {
            var p1 = this.content[j].p1;
            var p2 = this.content[j].p2;
            var value = "S"+this.id+"-";
                      
            if(p2) {
                this.content[j].draw();
                         
                if(j == 0) {
                    if(p1.printed) {
                      canvas.drawText(value+index, p1.x, p1.y);
                      index++;
                      p1.printed = false;
                    }
                    
                } 
                           
                if(i == this.size() - 1) { //last element
                    if(!p2.equal(this.content[j].p1)) {
                        if(p2.printed) {
                          canvas.drawText(value+index, p2.x, p2.y);
                           index++;
                           p2.printed = false;
                        }
                       
                    }
                } else {
                   if(p2.printed) {
                    canvas.drawText(value+index, p2.x, p2.y);
                     index++;
                     p2.printed = false;
                   }
                   
                }
             } else {
                if(p1.printed) {
                  canvas.drawCoordinates(p1.x, p1.y);
                  canvas.drawText(value+index, p1.x, p1.y);
                   index++;
                   p1.printed = false;
                }
                 
             }
        }
   }
   
   this.remove = function(x, y) {
      var position = new Point2D(x, y);
      for (var j = 0; j < this.size(); j++) {
          var segment = this.content[j];
          var pToDelete = 0;
          var ns = [];
          this.firstSegment = false;
                  
           if(position.distance(segment.p1) <= canvas.pointSize) {
              pToDelete = 1;
           } else if(position.distance(segment.p2) <= canvas.pointSize) {
              pToDelete = 2;
           }
           
           if(j == 0 && pToDelete == 1) { //cas particulier de 1er
               console.log("first");
              for (var k = 1; k < this.size(); k++) {
                ns.push(this.content[k]);
              }
              if(ns.length == 0) {
                this.firstSegment = true;
              }
              this.content = ns;
              return;
            } else if(j == this.size() - 1 && pToDelete == 2) { // cas du dernier element
                for (var k = 0; k < this.size() - 1; k++) {
                  ns.push(this.content[k]);
                }
                if(ns.length == 0) {
                  this.firstSegment = true;
                }
                this.content = ns;
                return;
            } else if(pToDelete > 0) {
              for (var k = 0; k < this.size(); k++) {
                if(k == j) {
                  var old = this.content[k];
                  var old2 = this.content[k+1];
                  var p1 = new Point2D(old.p1.x, old.p1.y);
                  var p2 = new Point2D(old2.p2.x, old2.p2.y);
                  var newss = new Segment2D(p1, p2);
                  ns.push(newss);
                } else {
                  if(j+1 == k) {
                    //nothing to do                         
                  } else {
                    ns.push(this.content[k]);
                  }
                }
              }
                if(ns.length == 0) {
                  this.firstSegment = true;
                }
                this.content = ns;
                return;
            }
          }
   }
  
   this.size = function() {
     return this.content.length;
   }
   
   this.toYML = function() {
     var txt = "";
     
     if(this.size() > 0) {
        txt = "[[";
      
          for (var j = 0; j < this.size(); j++) {
             var s = this.content[j];
             if(j == 0) {
               txt = txt + s.p1.toYML() + ", ";
             } 
             
             if(j < this.size()-1) {
               txt = txt + s.p2.toYML() + ", ";
             } else {
               txt = txt + s.p2.toYML();
             }
           }
        txt = txt + "]]";
     }
     
     return txt;
   }
  
   this.toMOM = function() {
      var txt = "";
     
       if(this.size() > 0) {
        txt = "#LineString";

        if(this.isPolygon()) {
          txt = "#Polygon";
        }

        txt = txt + "\n";
        
           for (var j = 0; j < this.size(); j++) {
             var s = this.content[j];
             if(j == 0) {
               txt = txt + s.p1.toMOM() +  "\n";
             }
             txt = txt + s.p2.toMOM() + "\n";
           }
      }
  
      return txt;
   }
   
   this.isLineString = function() {
      if(this.size() < 1) {
        return false;
      }
    
      if(this.size() == 1) {
        return true;
      }
    
      var firstP = this.content[0].p1;
      var lastP = this.content[this.size()-1].p2;
    
      return !firstP.equal(lastP);
   }
   
   this.isPolygon = function() {
     //TODO fermet le segment si polygon;
      if(this.size() < 2) {
        return false;
      }
  
    
      var firstP = this.content[0].p1;
      var lastP = this.content[this.size()-1].p2;
    
      return firstP.equal(lastP);
   }
}

//===========================================================================

var Partition = function (id) {
   this.id = id;
   this.content = [];
   this.alive = true;
   
   this.addNewPoint = function(x, y) {
      var point = new Point2D(x, y);
      this.content.push(point);
   }
   
   this.add = function(point) {
     this.content.push(point);
   }
   
   this.size = function() {
     return this.content.length;
   }
   
   this.draw = function() {
      for (var j = 0; j < this.size(); j++) {
        this.content[j].draw("P"+this.id+"-"+j);
      }
   }
   
   this.notEmpty = function() {
     return this.size() != 0;
   }
   
   this.movePoint = function(x, y) {
      var position = new Point2D(x, y);
      for (var j = 0; j < this.size(); j++) {
          var point = this.content[j];
          if(position.distance(point) <= canvas.pointSize) {
              zone.draggedPoint = point;
              return;
          }
      }
   }
  
    this.remove = function(x, y) {
      var position = new Point2D(x, y);
      for (var j = 0; j < this.size(); j++) {
          if(position.distance(this.content[j]) <= canvas.pointSize) {
            var np = [];
            for (var k = 0; k < j; k++) {
              np.push(this.content[k]);
            }
            for (var k = j+1; k < this.size(); k++) {
              np.push(this.content[k]);
            }
            this.content = np;
            return;
          }
       }
    }
    
    this.toYML = function() {
      var txt = "";
  
      if(this.size() > 0) {
        txt = '[';
    
        if(this.size() == 1) {
          txt = txt, this.content[0].toYML() + ']';
        } else {
          for (var j = 0; j < this.size()-1; j++) {
            txt = txt + this.content[j].toYML() + ', ';
          }
          txt = txt + this.content[j].toYML() + ']';
        }
      }

      return txt;
    }
    
    this.toMOM = function() {
       var txt = "";
       
       if(this.size() > 0) {
         txt = "#MultiPoint" + "\n";
         
         for (var j = 0; j < this.size()-1; j++) {
             txt = txt + this.content[j].toMOM()+ "\n";
         }
       }
    
       return txt;
    }
  
}

//===========================================================================

var ZoneP = function () {
  
  this.cidPoint = 0;
  this.cidSegment = 0;
  this.cidCurve = 0;
  
  this.pointsPartition = [];
  this.segmentsPartition = [];
  this.curvesPartition = [];
  
  this.dragStart = null;
  this.draggedPoint = null;
  
  this.newA = null;
  this.newB = null;
  
  this.newCA = null;
  this.newCB = null;
  
  this.pointsPartition[0] = new Partition(0);
  this.segmentsPartition[0] = new SegmentPartition(0);
  this.curvesPartition[0] = new Curve2D(0);
  
  this.rezet = function() {
    this.pointsPartition = [];
    this.segmentsPartition = [];
    this.curvesPartition = [];
        
    this.pointsPartition[0] = new Partition(0);
    this.segmentsPartition[0] = new SegmentPartition(0);
    this.curvesPartition[0] = new Curve2D(0);
        
    this.cidPoint = 0;
    this.cidSegment = 0;
    this.cidCurve = 0;
    
    this.MOM = "";
    this.YML = "";
    
  }
  
  this.addPoint = function(pt) {
    if(this.cidPoint != -1) {
      this.pointsPartition[this.cidPoint].addNewPoint(pt.x, pt.y);
    }
  }           
  
  this.addSegment = function(pt) {
    if(this.cidSegment != -1) {
      this.segmentsPartition[this.cidSegment].addNewPoint(pt.x, pt.y);
    }
  }
  
  this.addCurve = function(pt) {
    if(this.cidCurve != -1) {
      this.curvesPartition[this.cidCurve].addNewPoint(pt.x, pt.y);
    }
  }
  
  this.deletePoint = function(pt) {
    if(this.cidPoint != -1) {
      for (var i = 0; i < this.pointsPartition.length; i++) {
        this.pointsPartition[i].remove(pt.x, pt.y);
      }
    }
  }
  
  this.deleteSegment = function(pt) {
    if(this.cidSegment != -1) {
      for (var i = 0; i < this.segmentsPartition.length; i++) {
        this.segmentsPartition[i].remove(pt.x, pt.y);
      }
    }
  }
  
  this.deleteCurve = function(pt) {
    if(this.cidPoint != -1) {
      for (var i = 0; i < this.curvesPartition.length; i++) {
        this.curvesPartition[i].remove(pt.x, pt.y);
      }
    }
  }
  
  this.addPointCurve = function(pt) {
      if(this.cidCurve != -1) {
          var point = new Point2D(pt.x, pt.y);
          var partition = this.curvesPartition[this.cidCurve];
        
          for (var i = 0; i < partition.size(); i++) {
            var p = partition.points[i];
            
              if(this.newCA == null) {
                  if(point.distance(p) <= canvas.pointSize) {
                    this.newCA = p;
                  }
              } else if(this.newCB == null) {
                   if(point.distance(p) <= canvas.pointSize) {
                    this.newCB = p;
                  }
              }
          }
           
           if(this.newCA != null && this.newCB != null) {
                var p = this.newCA.middle(this.newCB);
                var indexA = 0;
                var indexB = 0;
                for (var j = 0; j < partition.size(); j++) {
                  var lastp = partition.points[j];
                  if(lastp.equal(this.newCA)) {
                    indexA = j;
                  }
                  if(lastp.equal(this.newCB)) {
                    indexB = j;
                  }
                }
                
                var index = Math.min(indexA, indexB);
                var c = [];
                
                for (var k = 0; k <= index; k++) {
                  c.push(partition.points[k]);
                }
                
                c.push(p);
                
                 for (var k = index+1; k < partition.size(); k++) {
                   c.push(partition.points[k]);
                 }
                
                partition.points = c;
                this.newCA = null;
                this.newCB = null;
           }
      }
  }
  
  this.addPoinSegment = function(pt) {
          if(this.cidSegment != -1) {
            var point = new Point2D(pt.x, pt.y);
            
                var partition = this.segmentsPartition[this.cidSegment];
                for (var j = 0; j < partition.size(); j++) {
                    var segment = partition.content[j];
                    var d1 = point.distance(segment.p1);
                    var d2 = point.distance(segment.p2);
                    
                    if(this.newA == null) {
                      if(d1 <= canvas.pointSize) {
                         this.newA = segment.p1;
                         return;
                      } else if(d2 <= canvas.pointSize) {
                         this.newA = segment.p2;
                         return;
                      }
                    } else if(this.newB == null) {
                        if(d1 <= canvas.pointSize) {
                           this.newB = segment.p1;
                        } else if(d2 <= canvas.pointSize) {
                           this.newB = segment.p2;
                        }
                    }
                }
                
                if(this.newA != null && this.newB == null) {
                    this.newB = point; //segment with new point
                }
                
                if(this.newA != null && this.newB != null) {
                    for (var j = 0; j < partition.size(); j++) {
                        var segment = partition.content[j];
                        var ns = new Segment2D(this.newA, this.newB);
                        if(ns.equal(segment)) {
                            var p = segment.p1.middle(segment.p2);
                            var s1 = new Segment2D(segment.p1, p);
                            var s2 = new Segment2D(p, segment.p2);
                            var c = [];
                            for (var k = 0; k < j; k++) {
                               c.push(partition.content[k]);
                            }
                            c.push(s1);
                            c.push(s2);
                            for (var k = j+1; k < partition.size(); k++) {
                               c.push(partition.content[k]);
                            }
                            partition.content = c;
                            this.newA = null;
                            this.newB = null;
                            return;
                        }
                    }
                    
                    partition.addNewSegment(this.newA, this.newB);
                    this.newA = null;
                    this.newB = null;
                }
            }
  }
  
  this.movePoint = function(pt) {
    for (var i = 0; i < this.pointsPartition.length; i++) {
      this.pointsPartition[i].movePoint(pt.x, pt.y);
    }
  }
  
  this.moveSegment = function(pt) {
    for (var i = 0; i < this.segmentsPartition.length; i++) {
      this.segmentsPartition[i].movePoint(pt.x, pt.y);
    }
  }
  
  this.moveCurve = function(pt) {
    for (var i = 0; i < this.curvesPartition.length; i++) {
      this.curvesPartition[i].movePoint(pt.x, pt.y);
    }
  }
  
  this.drawPoints = function() {
    for (var i = 0; i < this.pointsPartition.length; i++) {
      this.pointsPartition[i].draw();
    }
  }
  
  this.drawSegments = function() {
    for (var i = 0; i < this.segmentsPartition.length; i++) {
      this.segmentsPartition[i].draw();
    }
  }
  
  this.drawcurves = function() {
    for (var i = 0; i < this.curvesPartition.length; i++) {
      canvas.drawBezier(i, this.curvesPartition[i].points);
    }
  }
  
  this.createMOMFile = function() {
    
    for (var i = 0; i < this.pointsPartition.length; i++) {
      this.MOM += this.pointsPartition[i].toMOM();
    }
    
    for (var i = 0; i < this.segmentsPartition.length; i++) {
      this.MOM += this.segmentsPartition[i].toMOM();
    }
    
    for (var i = 0; i < this.curvesPartition.length; i++) {
      this.MOM += this.curvesPartition[i].toMOM();
    }
    
  }
  
  this.createYMLFile = function() {
    
  this.YML += '  MultiPoints: [' + '\n';
  
    if(this.pointsPartition.length == 1) {
       this.YML += this.pointsPartition[0].toYML();
    } else {
      for (var i = 0; i < this.pointsPartition.length - 1; i++) {
        if(this.pointsPartition[i].notEmpty()) {
          this.YML += this.pointsPartition[i].toYML() + ", \n";
        }
      }
      this.YML += this.pointsPartition[this.pointsPartition.length - 1].toYML();
    }
    
     this.YML += "\n]\n";
     
     this.YML += '  MultiLineString: [' + '\n';
     
     var indexLine = 0;
     

        
        for (var i = 0; i < this.segmentsPartition.length; i++) {
          if(this.segmentsPartition[i].isLineString()) {
            indexLine++;
            if(indexLine == 1) {
              this.YML += this.segmentsPartition[i].toYML();
            } else {
              if(this.segmentsPartition[i].notEmpty()) {
                this.YML += ",\n" + this.segmentsPartition[i].toYML();
              }
            }
          }
        }
        
         var firstO = true;
        
          if(canvas.typeofcurve == "open") {
            for (var i = 0; i < this.curvesPartition.length; i++) {
              if(i < this.curvesPartition.length - 1) {
                if(this.curvesPartition[i].notEmpty()) {
                  if(firstO) {
                    firstO = false;
                    if(indexLine > 0) {
                      this.YML += ",";
                    }
                    this.YML += "\n";
                  }
                  this.YML += this.curvesPartition[i].toYML() + ",\n";
                }
              } else {
                 if(firstO) {
                    firstO = false;
                    if(indexLine > 0) {
                      this.YML += ",";
                    }
                    this.YML += "\n";
                  }
                this.YML += this.curvesPartition[i].toYML() + "\n";
              }
              
            }  
          }
     
     
     this.YML += "\n]\n";
     
     this.YML += '  MultiPolygon: [' + '\n';
     
      var indexPoly = 0;
     
        for (var i = 0; i < this.segmentsPartition.length; i++) {
          if(this.segmentsPartition[i].isPolygon()) {
            indexPoly++;
            if(indexPoly == 1) {
              this.YML += this.segmentsPartition[i].toYML();
            } else {
              if(this.segmentsPartition[i].notEmpty()) {
              this.YML += ",\n" + this.segmentsPartition[i].toYML();
              }
            }
          }
        }
        
        var firstC = true;
        
         if(canvas.typeofcurve == "close") {
            for (var i = 0; i < this.curvesPartition.length; i++) {
            
              if(i < this.curvesPartition.length - 1) {
                if(this.curvesPartition[i].notEmpty()) {
                  if(firstC) {
                    firstC = false;
                    if(indexPoly > 0) {
                      this.YML += ",";
                    }
                    this.YML += "\n";
                  }
                  this.YML += this.curvesPartition[i].toYML() + ",\n";
                }
              } else {
                
                 if(firstC) {
                    firstC = false;
                    if(indexPoly > 0) {
                      this.YML += ",";
                    }
                    this.YML += "\n";
                  }
                this.YML += this.curvesPartition[i].toYML() + "\n";
              }
            }  
          }
     
     this.YML += "\n]\n";
  }
  
  this.save = function() {
    this.YML = "";
    this.MOM = "";
    this.createMOMFile();
    this.createYMLFile();
  }

}

//===========================================================================

$(document).keypress(function(e){
 
        var key = e.originalEvent.key;
      
        if(key == "p") {
            actionChangeMode("drawPoint");
        } else if(key == "m") {
            actionChangeMode("move");
        } else if (key == "s") {
            actionChangeMode("drawSegment");
        } else if (key == "c") {
            actionChangeMode("drawCurve");
        } else if (canvas.started && key == "r") {
              canvas.newEnv();
              canvas.redraw();
        } else {
          
        }
});

  </script>